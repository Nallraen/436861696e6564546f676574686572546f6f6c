#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Character

#include "Basic.hpp"

#include "BP_Character_classes.hpp"
#include "BP_Character_parameters.hpp"


namespace SDK
{

// Function BP_Character.BP_Character_C.ActivateCollisions
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Active                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ActivateCollisions(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ActivateCollisions");

	Params::BP_Character_C_ActivateCollisions Parms{};

	Parms.Active = Active;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AdaptSwimCollision
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Swim                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AdaptSwimCollision(bool Param_Swim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AdaptSwimCollision");

	Params::BP_Character_C_AdaptSwimCollision Parms{};

	Parms.Param_Swim = Param_Swim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.Add Chain
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            OtherCharacter                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::Add_Chain(const class APawn* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Add Chain");

	Params::BP_Character_C_Add_Chain Parms{};

	Parms.OtherCharacter = OtherCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.Add Character Constraint
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Constraint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::Add_Character_Constraint(class AActor* Constraint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Add Character Constraint");

	Params::BP_Character_C_Add_Character_Constraint Parms{};

	Parms.Constraint = Constraint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddAttachedCharacter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddAttachedCharacter(class APawn* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddAttachedCharacter");

	Params::BP_Character_C_AddAttachedCharacter Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddChainPhysic
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Physics                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UStaticMeshComponent*             Comp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddChainPhysic(class UObject* Physics, class UStaticMeshComponent* Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddChainPhysic");

	Params::BP_Character_C_AddChainPhysic Parms{};

	Parms.Physics = Physics;
	Parms.Comp = Comp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddChainSocket
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddChainSocket(class UPrimitiveComponent* Socket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddChainSocket");

	Params::BP_Character_C_AddChainSocket Parms{};

	Parms.Socket = Socket;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddCloth
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMesh*                    NewMesh                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CustomMat                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               Material                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddCloth(class USkeletalMesh* NewMesh, const struct FLinearColor& Color, bool CustomMat, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddCloth");

	Params::BP_Character_C_AddCloth Parms{};

	Parms.NewMesh = NewMesh;
	Parms.Color = std::move(Color);
	Parms.CustomMat = CustomMat;
	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddClothes
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AddClothes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddClothes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AddConnectedChain
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Chain                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddConnectedChain(class AActor* Chain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddConnectedChain");

	Params::BP_Character_C_AddConnectedChain Parms{};

	Parms.Chain = Chain;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddForce
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Vector                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MakeSlide                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  StabilizeSpeed                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    PushedByTrain                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShuffleFixToGround                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddForce(const struct FVector& Vector, bool MakeSlide, double StabilizeSpeed, bool PushedByTrain, bool ShuffleFixToGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddForce");

	Params::BP_Character_C_AddForce Parms{};

	Parms.Vector = std::move(Vector);
	Parms.MakeSlide = MakeSlide;
	Parms.StabilizeSpeed = StabilizeSpeed;
	Parms.PushedByTrain = PushedByTrain;
	Parms.ShuffleFixToGround = ShuffleFixToGround;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddImpulseToCar
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Impulse                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddImpulseToCar(const struct FVector& Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddImpulseToCar");

	Params::BP_Character_C_AddImpulseToCar Parms{};

	Parms.Impulse = std::move(Impulse);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddImpulseToCharacter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Impulse                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OverrideVelocityZ                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    StopClimb                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_ShuffleAirControl                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IgnoreDoOnce                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_PushedByObstacle                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddImpulseToCharacter(const struct FVector& Impulse, bool OverrideVelocityZ, bool StopClimb, bool Param_ShuffleAirControl, bool IgnoreDoOnce, bool Param_PushedByObstacle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddImpulseToCharacter");

	Params::BP_Character_C_AddImpulseToCharacter Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.OverrideVelocityZ = OverrideVelocityZ;
	Parms.StopClimb = StopClimb;
	Parms.Param_ShuffleAirControl = Param_ShuffleAirControl;
	Parms.IgnoreDoOnce = IgnoreDoOnce;
	Parms.Param_PushedByObstacle = Param_PushedByObstacle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddPhysX_Chain
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            OtherAttachedPawn                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_NewChain_C*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class ABP_NewChain_C* ABP_Character_C::AddPhysX_Chain(const class APawn* OtherAttachedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddPhysX_Chain");

	Params::BP_Character_C_AddPhysX_Chain Parms{};

	Parms.OtherAttachedPawn = OtherAttachedPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.AddWaterVolume
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Remove                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AddWaterVolume(bool Remove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddWaterVolume");

	Params::BP_Character_C_AddWaterVolume Parms{};

	Parms.Remove = Remove;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AddWingsSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AddWingsSRV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddWingsSRV");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AddZForceToPulledCharacter
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::AddZForceToPulledCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AddZForceToPulledCharacter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ALS_Tick
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ALS_Tick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ALS_Tick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.AnnulateVelocity
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AnnulateVelocity(double Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AnnulateVelocity");

	Params::BP_Character_C_AnnulateVelocity Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AnulateCharacterVelocity
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AnulateCharacterVelocity(double Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AnulateCharacterVelocity");

	Params::BP_Character_C_AnulateCharacterVelocity Parms{};

	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ApplyStepMovement
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  New_Location_Z                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ApplyStepMovement(double New_Location_Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ApplyStepMovement");

	Params::BP_Character_C_ApplyStepMovement Parms{};

	Parms.New_Location_Z = New_Location_Z;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AttachBalancierAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Param_Balancier                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   MaillonIndex                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AttachBalancierAll(class AActor* Param_Balancier, int32 MaillonIndex, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AttachBalancierAll");

	Params::BP_Character_C_AttachBalancierAll Parms{};

	Parms.Param_Balancier = Param_Balancier;
	Parms.MaillonIndex = MaillonIndex;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AttachBalancierServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Param_Balancier                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   MaillonIndex                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AttachBalancierServer(class AActor* Param_Balancier, int32 MaillonIndex, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AttachBalancierServer");

	Params::BP_Character_C_AttachBalancierServer Parms{};

	Parms.Param_Balancier = Param_Balancier;
	Parms.MaillonIndex = MaillonIndex;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.AttachedCharactersAreSwiming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::AttachedCharactersAreSwiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AttachedCharactersAreSwiming");

	Params::BP_Character_C_AttachedCharactersAreSwiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.AttachToBalancier
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Param_Balancier                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_BalancierMaillon                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::AttachToBalancier(class AActor* Param_Balancier, int32 Param_BalancierMaillon, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "AttachToBalancier");

	Params::BP_Character_C_AttachToBalancier Parms{};

	Parms.Param_Balancier = Param_Balancier;
	Parms.Param_BalancierMaillon = Param_BalancierMaillon;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BeAttractedBySun
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              SunMesh                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BeAttractedBySun(class UPrimitiveComponent* SunMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BeAttractedBySun");

	Params::BP_Character_C_BeAttractedBySun Parms{};

	Parms.SunMesh = SunMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BeginCinematic
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       BeginTransform                                         (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BeginCinematic(const struct FTransform& BeginTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BeginCinematic");

	Params::BP_Character_C_BeginCinematic Parms{};

	Parms.BeginTransform = std::move(BeginTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BeginClimb
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         NewRotation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Loc                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BeginClimb(const struct FRotator& NewRotation, const struct FVector& Loc, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BeginClimb");

	Params::BP_Character_C_BeginClimb Parms{};

	Parms.NewRotation = std::move(NewRotation);
	Parms.Loc = std::move(Loc);
	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BeginGridConstraint
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::BeginGridConstraint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BeginGridConstraint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.BeginPullOtherCharacter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    BeginPull                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherCharacter                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BeginPullOtherCharacter(bool BeginPull, class AActor* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BeginPullOtherCharacter");

	Params::BP_Character_C_BeginPullOtherCharacter Parms{};

	Parms.BeginPull = BeginPull;
	Parms.OtherCharacter = OtherCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BeltFallDown
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::BeltFallDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BeltFallDown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.BndEvt__BP_BallMovement_Sphere_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Character_C::BndEvt__BP_BallMovement_Sphere_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BndEvt__BP_BallMovement_Sphere_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature");

	Params::BP_Character_C_BndEvt__BP_BallMovement_Sphere_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BndEvt__BP_Character_Capsule_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Character_C::BndEvt__BP_Character_Capsule_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BndEvt__BP_Character_Capsule_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_Character_C_BndEvt__BP_Character_Capsule_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BounceAnim
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::BounceAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BounceAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.BounceOnTrampoline
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Bounce                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Instigator                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseControlRot                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    JustZ                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BounceOnTrampoline(double Bounce, bool Param_Instigator, bool UseControlRot, bool JustZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BounceOnTrampoline");

	Params::BP_Character_C_BounceOnTrampoline Parms{};

	Parms.Bounce = Bounce;
	Parms.Param_Instigator = Param_Instigator;
	Parms.UseControlRot = UseControlRot;
	Parms.JustZ = JustZ;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BounceOnTrampolineClient
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Bounce                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Instigator                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseControlRot                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    JustZ                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BounceOnTrampolineClient(double Bounce, bool Param_Instigator, bool UseControlRot, bool JustZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BounceOnTrampolineClient");

	Params::BP_Character_C_BounceOnTrampolineClient Parms{};

	Parms.Bounce = Bounce;
	Parms.Param_Instigator = Param_Instigator;
	Parms.UseControlRot = UseControlRot;
	Parms.JustZ = JustZ;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BounceTrampolineAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Bounce                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Instigator                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseControlRot                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    JustZ                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BounceTrampolineAll(double Bounce, bool Param_Instigator, bool UseControlRot, bool JustZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BounceTrampolineAll");

	Params::BP_Character_C_BounceTrampolineAll Parms{};

	Parms.Bounce = Bounce;
	Parms.Param_Instigator = Param_Instigator;
	Parms.UseControlRot = UseControlRot;
	Parms.JustZ = JustZ;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BounceTrampolineSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Bounce                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Instigator                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseControlRot                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    JustZ                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BounceTrampolineSRV(double Bounce, bool Param_Instigator, bool UseControlRot, bool JustZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BounceTrampolineSRV");

	Params::BP_Character_C_BounceTrampolineSRV Parms{};

	Parms.Bounce = Bounce;
	Parms.Param_Instigator = Param_Instigator;
	Parms.UseControlRot = UseControlRot;
	Parms.JustZ = JustZ;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BPI_Get_CurrentStates
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMovementMode                           PawnMovementMode                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_MovementState                      Param_MovementState                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_MovementState                      Param_PrevMovementState                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_MovementAction                     Param_MovementAction                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_RotationMode                       Param_RotationMode                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_Gait                               ActualGait                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_Stance                             Param_ActualStance                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_ViewMode                           Param_ViewMode                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EALS_OverlayState                       Param_OverlayState                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BPI_Get_CurrentStates(EMovementMode* PawnMovementMode, EALS_MovementState* Param_MovementState, EALS_MovementState* Param_PrevMovementState, EALS_MovementAction* Param_MovementAction, EALS_RotationMode* Param_RotationMode, EALS_Gait* ActualGait, EALS_Stance* Param_ActualStance, EALS_ViewMode* Param_ViewMode, EALS_OverlayState* Param_OverlayState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BPI_Get_CurrentStates");

	Params::BP_Character_C_BPI_Get_CurrentStates Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PawnMovementMode != nullptr)
		*PawnMovementMode = Parms.PawnMovementMode;

	if (Param_MovementState != nullptr)
		*Param_MovementState = Parms.Param_MovementState;

	if (Param_PrevMovementState != nullptr)
		*Param_PrevMovementState = Parms.Param_PrevMovementState;

	if (Param_MovementAction != nullptr)
		*Param_MovementAction = Parms.Param_MovementAction;

	if (Param_RotationMode != nullptr)
		*Param_RotationMode = Parms.Param_RotationMode;

	if (ActualGait != nullptr)
		*ActualGait = Parms.ActualGait;

	if (Param_ActualStance != nullptr)
		*Param_ActualStance = Parms.Param_ActualStance;

	if (Param_ViewMode != nullptr)
		*Param_ViewMode = Parms.Param_ViewMode;

	if (Param_OverlayState != nullptr)
		*Param_OverlayState = Parms.Param_OverlayState;
}


// Function BP_Character.BP_Character_C.BPI_Get_EssentialValues
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Velocity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Param_Acceleration                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          MovementInput                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_IsMoving                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_HasMovementInput                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Param_Speed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Param_MovementInputAmount                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         AimingRotation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double                                  Param_AimYawRate                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           PullCharacter                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Pull                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Climb                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        MoveInput                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SwimOnSurface                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Param_LeftHandLocation                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Param_RightHandLocation                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RadialVelocityRight                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RadialVelocityUp                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Swim                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Bounce                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    LookAround                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Balancier                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BPI_Get_EssentialValues(struct FVector* Velocity, struct FVector* Param_Acceleration, struct FVector* MovementInput, bool* Param_IsMoving, bool* Param_HasMovementInput, double* Param_Speed, double* Param_MovementInputAmount, struct FRotator* AimingRotation, double* Param_AimYawRate, class AActor** PullCharacter, bool* Pull, bool* Climb, struct FVector2D* MoveInput, bool* SwimOnSurface, struct FVector* Param_LeftHandLocation, struct FVector* Param_RightHandLocation, double* RadialVelocityRight, double* RadialVelocityUp, bool* Param_Swim, bool* Bounce, bool* LookAround, bool* Param_Balancier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BPI_Get_EssentialValues");

	Params::BP_Character_C_BPI_Get_EssentialValues Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Velocity != nullptr)
		*Velocity = std::move(Parms.Velocity);

	if (Param_Acceleration != nullptr)
		*Param_Acceleration = std::move(Parms.Param_Acceleration);

	if (MovementInput != nullptr)
		*MovementInput = std::move(Parms.MovementInput);

	if (Param_IsMoving != nullptr)
		*Param_IsMoving = Parms.Param_IsMoving;

	if (Param_HasMovementInput != nullptr)
		*Param_HasMovementInput = Parms.Param_HasMovementInput;

	if (Param_Speed != nullptr)
		*Param_Speed = Parms.Param_Speed;

	if (Param_MovementInputAmount != nullptr)
		*Param_MovementInputAmount = Parms.Param_MovementInputAmount;

	if (AimingRotation != nullptr)
		*AimingRotation = std::move(Parms.AimingRotation);

	if (Param_AimYawRate != nullptr)
		*Param_AimYawRate = Parms.Param_AimYawRate;

	if (PullCharacter != nullptr)
		*PullCharacter = Parms.PullCharacter;

	if (Pull != nullptr)
		*Pull = Parms.Pull;

	if (Climb != nullptr)
		*Climb = Parms.Climb;

	if (MoveInput != nullptr)
		*MoveInput = std::move(Parms.MoveInput);

	if (SwimOnSurface != nullptr)
		*SwimOnSurface = Parms.SwimOnSurface;

	if (Param_LeftHandLocation != nullptr)
		*Param_LeftHandLocation = std::move(Parms.Param_LeftHandLocation);

	if (Param_RightHandLocation != nullptr)
		*Param_RightHandLocation = std::move(Parms.Param_RightHandLocation);

	if (RadialVelocityRight != nullptr)
		*RadialVelocityRight = Parms.RadialVelocityRight;

	if (RadialVelocityUp != nullptr)
		*RadialVelocityUp = Parms.RadialVelocityUp;

	if (Param_Swim != nullptr)
		*Param_Swim = Parms.Param_Swim;

	if (Bounce != nullptr)
		*Bounce = Parms.Bounce;

	if (LookAround != nullptr)
		*LookAround = Parms.LookAround;

	if (Param_Balancier != nullptr)
		*Param_Balancier = Parms.Param_Balancier;
}


// Function BP_Character.BP_Character_C.BPI_Set_Gait
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_Gait                               NewGait                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BPI_Set_Gait(EALS_Gait NewGait)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BPI_Set_Gait");

	Params::BP_Character_C_BPI_Set_Gait Parms{};

	Parms.NewGait = NewGait;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BPI_Set_MovementAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_MovementAction                     NewMovementAction                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BPI_Set_MovementAction(EALS_MovementAction NewMovementAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BPI_Set_MovementAction");

	Params::BP_Character_C_BPI_Set_MovementAction Parms{};

	Parms.NewMovementAction = NewMovementAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BPI_Set_MovementState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_MovementState                      NewMovementState                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BPI_Set_MovementState(EALS_MovementState NewMovementState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BPI_Set_MovementState");

	Params::BP_Character_C_BPI_Set_MovementState Parms{};

	Parms.NewMovementState = NewMovementState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BPI_Set_OverlayState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_OverlayState                       NewOverlayState                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BPI_Set_OverlayState(EALS_OverlayState NewOverlayState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BPI_Set_OverlayState");

	Params::BP_Character_C_BPI_Set_OverlayState Parms{};

	Parms.NewOverlayState = NewOverlayState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BPI_Set_RotationMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_RotationMode                       NewRotationMode                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BPI_Set_RotationMode(EALS_RotationMode NewRotationMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BPI_Set_RotationMode");

	Params::BP_Character_C_BPI_Set_RotationMode Parms{};

	Parms.NewRotationMode = NewRotationMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.BPI_Set_ViewMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_ViewMode                           NewViewMode                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::BPI_Set_ViewMode(EALS_ViewMode NewViewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "BPI_Set_ViewMode");

	Params::BP_Character_C_BPI_Set_ViewMode Parms{};

	Parms.NewViewMode = NewViewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.CacheValues
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CacheValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CacheValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CalculateAcceleration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_Character_C::CalculateAcceleration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CalculateAcceleration");

	Params::BP_Character_C_CalculateAcceleration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.CalculateFloorNormal
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FVector                          ImpactNormal                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::CalculateFloorNormal(const struct FHitResult& Hit, struct FVector* ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CalculateFloorNormal");

	Params::BP_Character_C_CalculateFloorNormal Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	if (ImpactNormal != nullptr)
		*ImpactNormal = std::move(Parms.ImpactNormal);
}


// Function BP_Character.BP_Character_C.CalculateGroundedRotationRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_Character_C::CalculateGroundedRotationRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CalculateGroundedRotationRate");

	Params::BP_Character_C_CalculateGroundedRotationRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.CalculateRadialVel
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CalculateRadialVel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CalculateRadialVel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CalculateVelocity
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CalculateVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CalculateVelocity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CanUpdateMovingRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::CanUpdateMovingRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CanUpdateMovingRotation");

	Params::BP_Character_C_CanUpdateMovingRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.CapsuleHasRoomCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UCapsuleComponent*                Param_Capsule                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TargetLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  HeightOffset                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RadiusOffset                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDrawDebugTrace                         DebugType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    HasRoom                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::CapsuleHasRoomCheck(class UCapsuleComponent* Param_Capsule, const struct FVector& TargetLocation, double HeightOffset, double RadiusOffset, EDrawDebugTrace DebugType, const TArray<class AActor*>& ActorsToIgnore, bool* HasRoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CapsuleHasRoomCheck");

	Params::BP_Character_C_CapsuleHasRoomCheck Parms{};

	Parms.Param_Capsule = Param_Capsule;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.HeightOffset = HeightOffset;
	Parms.RadiusOffset = RadiusOffset;
	Parms.DebugType = DebugType;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	UObject::ProcessEvent(Func, &Parms);

	if (HasRoom != nullptr)
		*HasRoom = Parms.HasRoom;
}


// Function BP_Character.BP_Character_C.ChainAlreadyExist?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Player01                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APawn*                            Player02                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::ChainAlreadyExist_(class APawn* Player01, class APawn* Player02)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ChainAlreadyExist?");

	Params::BP_Character_C_ChainAlreadyExist_ Parms{};

	Parms.Player01 = Player01;
	Parms.Player02 = Player02;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.ChangeCurrentVehicle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Vehicle                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ChangeCurrentVehicle(class AActor* Vehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ChangeCurrentVehicle");

	Params::BP_Character_C_ChangeCurrentVehicle Parms{};

	Parms.Vehicle = Vehicle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.Character Bounce
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::Character_Bounce(double Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Character Bounce");

	Params::BP_Character_C_Character_Bounce Parms{};

	Parms.Force = Force;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.CheckDeathInLava
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CheckDeathInLava()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CheckDeathInLava");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CheckForTrampoline
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CheckForTrampoline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CheckForTrampoline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CheckMaxDistanceWithOthers
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::CheckMaxDistanceWithOthers(float* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CheckMaxDistanceWithOthers");

	Params::BP_Character_C_CheckMaxDistanceWithOthers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function BP_Character.BP_Character_C.ClientLocationSRV
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Param_ClientRepLocation                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ClientLocationSRV(const struct FVector& Param_ClientRepLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ClientLocationSRV");

	Params::BP_Character_C_ClientLocationSRV Parms{};

	Parms.Param_ClientRepLocation = std::move(Param_ClientRepLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ClimbAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         NewRotation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Loc                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ClimbAll(const struct FRotator& NewRotation, const struct FVector& Loc, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ClimbAll");

	Params::BP_Character_C_ClimbAll Parms{};

	Parms.NewRotation = std::move(NewRotation);
	Parms.Loc = std::move(Loc);
	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ClimbSideTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  SideDistance                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ForwardDistance                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ClimbableWall                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ClimbSideTrace(double SideDistance, double ForwardDistance, bool* ClimbableWall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ClimbSideTrace");

	Params::BP_Character_C_ClimbSideTrace Parms{};

	Parms.SideDistance = SideDistance;
	Parms.ForwardDistance = ForwardDistance;

	UObject::ProcessEvent(Func, &Parms);

	if (ClimbableWall != nullptr)
		*ClimbableWall = Parms.ClimbableWall;
}


// Function BP_Character.BP_Character_C.ClimbSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         NewRotation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Loc                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Stop                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ClimbSRV(const struct FRotator& NewRotation, const struct FVector& Loc, const struct FVector& Normal, bool Stop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ClimbSRV");

	Params::BP_Character_C_ClimbSRV Parms{};

	Parms.NewRotation = std::move(NewRotation);
	Parms.Loc = std::move(Loc);
	Parms.Normal = std::move(Normal);
	Parms.Stop = Stop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.CustomEvent
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CustomEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CustomEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CustomEvent_0
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CustomEvent_0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CustomEvent_0");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.CustomEvent_1
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::CustomEvent_1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "CustomEvent_1");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.DeactivateCustomDepth
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::DeactivateCustomDepth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DeactivateCustomDepth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.DetachFromBalancier
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::DetachFromBalancier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetachFromBalancier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.DetectBalancier
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::DetectBalancier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetectBalancier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.DetectChainViolation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Violation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::DetectChainViolation(bool* Violation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetectChainViolation");

	Params::BP_Character_C_DetectChainViolation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Violation != nullptr)
		*Violation = Parms.Violation;
}


// Function BP_Character.BP_Character_C.DetectClimbableWall
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::DetectClimbableWall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetectClimbableWall");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.DetectDesync
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Desync                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::DetectDesync(bool* Desync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetectDesync");

	Params::BP_Character_C_DetectDesync Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Desync != nullptr)
		*Desync = Parms.Desync;
}


// Function BP_Character.BP_Character_C.DetectFalldown
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::DetectFalldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetectFalldown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.DetectGrounded
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::DetectGrounded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetectGrounded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.DetectStuck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Stuck                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ZFix                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::DetectStuck(bool* Stuck, double* ZFix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetectStuck");

	Params::BP_Character_C_DetectStuck Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Stuck != nullptr)
		*Stuck = Parms.Stuck;

	if (ZFix != nullptr)
		*ZFix = Parms.ZFix;
}


// Function BP_Character.BP_Character_C.DetectSwimOrDive
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::DetectSwimOrDive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "DetectSwimOrDive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Dissolve_TL__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Dissolve_TL__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Dissolve_TL__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Dissolve_TL__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Dissolve_TL__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Dissolve_TL__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.EmissiveDissolve_TL__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::EmissiveDissolve_TL__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "EmissiveDissolve_TL__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.EmissiveDissolve_TL__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::EmissiveDissolve_TL__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "EmissiveDissolve_TL__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.EnableMovements
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::EnableMovements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "EnableMovements");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.EndCinematic
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::EndCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "EndCinematic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ExecuteUbergraph_BP_Character
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ExecuteUbergraph_BP_Character(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ExecuteUbergraph_BP_Character");

	Params::BP_Character_C_ExecuteUbergraph_BP_Character Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.Falldown
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Falldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Falldown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Find Chain Physics
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Char                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class FString                           Char02                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    Cosmetics                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_Chain_C*                      Chain                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::Find_Chain_Physics(const class FString& Char, const class FString& Char02, bool Cosmetics, class ABP_Chain_C** Chain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Find Chain Physics");

	Params::BP_Character_C_Find_Chain_Physics Parms{};

	Parms.Char = std::move(Char);
	Parms.Char02 = std::move(Char02);
	Parms.Cosmetics = Cosmetics;

	UObject::ProcessEvent(Func, &Parms);

	if (Chain != nullptr)
		*Chain = Parms.Chain;

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.FixCapsuleRotation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::FixCapsuleRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FixCapsuleRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FixClimbersDistance
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::FixClimbersDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FixClimbersDistance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FixFirstMaillon
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::FixFirstMaillon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FixFirstMaillon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FixPlayerToGround
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Fixation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::FixPlayerToGround(bool* Fixation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FixPlayerToGround");

	Params::BP_Character_C_FixPlayerToGround Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Fixation != nullptr)
		*Fixation = Parms.Fixation;
}


// Function BP_Character.BP_Character_C.Flotter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Flotte                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::Flotter(bool Param_Flotte)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Flotter");

	Params::BP_Character_C_Flotter Parms{};

	Parms.Param_Flotte = Param_Flotte;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.FlushJumpedFromBalancier
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::FlushJumpedFromBalancier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FlushJumpedFromBalancier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FlushJumping
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::FlushJumping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FlushJumping");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FlushSync
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::FlushSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FlushSync");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.FlushTransform
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          New_Transform_Location                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         New_Transform_Rotation                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double                                  Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::FlushTransform(const struct FVector& New_Transform_Location, const struct FRotator& New_Transform_Rotation, double Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "FlushTransform");

	Params::BP_Character_C_FlushTransform Parms{};

	Parms.New_Transform_Location = std::move(New_Transform_Location);
	Parms.New_Transform_Rotation = std::move(New_Transform_Rotation);
	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.Get Belt Fall Cam Loc Rot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Loc                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rot                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::Get_Belt_Fall_Cam_Loc_Rot(struct FVector* Loc, struct FRotator* Rot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Get Belt Fall Cam Loc Rot");

	Params::BP_Character_C_Get_Belt_Fall_Cam_Loc_Rot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Loc != nullptr)
		*Loc = std::move(Parms.Loc);

	if (Rot != nullptr)
		*Rot = std::move(Parms.Rot);
}


// Function BP_Character.BP_Character_C.GetAllConnectedChainPhysics
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Cosmetics                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ABP_Chain_C*>              Chains                                                 (Parm, OutParm)

void ABP_Character_C::GetAllConnectedChainPhysics(bool Cosmetics, TArray<class ABP_Chain_C*>* Chains)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetAllConnectedChainPhysics");

	Params::BP_Character_C_GetAllConnectedChainPhysics Parms{};

	Parms.Cosmetics = Cosmetics;

	UObject::ProcessEvent(Func, &Parms);

	if (Chains != nullptr)
		*Chains = std::move(Parms.Chains);
}


// Function BP_Character.BP_Character_C.GetAnimCurveValue
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             CurveName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_Character_C::GetAnimCurveValue(class FName CurveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetAnimCurveValue");

	Params::BP_Character_C_GetAnimCurveValue Parms{};

	Parms.CurveName = CurveName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetAnimVariables
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Jump                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Fall                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          RadialVelocity                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        MoveInput                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Climb                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Pull                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Param_PulledCharacter                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsDriving                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          DriveLeftHand                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          DriveRightHand                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    LookAround                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetAnimVariables(bool* Jump, bool* Fall, struct FVector* RadialVelocity, struct FVector2D* MoveInput, bool* Climb, bool* Pull, class AActor** Param_PulledCharacter, bool* IsDriving, struct FVector* DriveLeftHand, struct FVector* DriveRightHand, bool* LookAround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetAnimVariables");

	Params::BP_Character_C_GetAnimVariables Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Jump != nullptr)
		*Jump = Parms.Jump;

	if (Fall != nullptr)
		*Fall = Parms.Fall;

	if (RadialVelocity != nullptr)
		*RadialVelocity = std::move(Parms.RadialVelocity);

	if (MoveInput != nullptr)
		*MoveInput = std::move(Parms.MoveInput);

	if (Climb != nullptr)
		*Climb = Parms.Climb;

	if (Pull != nullptr)
		*Pull = Parms.Pull;

	if (Param_PulledCharacter != nullptr)
		*Param_PulledCharacter = Parms.Param_PulledCharacter;

	if (IsDriving != nullptr)
		*IsDriving = Parms.IsDriving;

	if (DriveLeftHand != nullptr)
		*DriveLeftHand = std::move(Parms.DriveLeftHand);

	if (DriveRightHand != nullptr)
		*DriveRightHand = std::move(Parms.DriveRightHand);

	if (LookAround != nullptr)
		*LookAround = Parms.LookAround;
}


// Function BP_Character.BP_Character_C.GetAttachedCharacters
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ReturnParm)

TArray<class AActor*> ABP_Character_C::GetAttachedCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetAttachedCharacters");

	Params::BP_Character_C_GetAttachedCharacters Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetAttachedComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetAttachedComponent(class UPrimitiveComponent** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetAttachedComponent");

	Params::BP_Character_C_GetAttachedComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function BP_Character.BP_Character_C.GetBaseLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetBaseLocation(struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetBaseLocation");

	Params::BP_Character_C_GetBaseLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BP_Character.BP_Character_C.GetBeltLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetBeltLocation(struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetBeltLocation");

	Params::BP_Character_C_GetBeltLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BP_Character.BP_Character_C.GetBeltSocket
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetBeltSocket(class USceneComponent** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetBeltSocket");

	Params::BP_Character_C_GetBeltSocket Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function BP_Character.BP_Character_C.GetCalpsuleBaseLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ZOffset                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_Character_C::GetCalpsuleBaseLocation(double ZOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCalpsuleBaseLocation");

	Params::BP_Character_C_GetCalpsuleBaseLocation Parms{};

	Parms.ZOffset = ZOffset;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetCapsuleBase
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USphereComponent*                 base                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetCapsuleBase(class USphereComponent** base)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCapsuleBase");

	Params::BP_Character_C_GetCapsuleBase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (base != nullptr)
		*base = Parms.base;
}


// Function BP_Character.BP_Character_C.GetCapsuleComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCapsuleComponent*                Param_Capsule                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetCapsuleComponent(class UCapsuleComponent** Param_Capsule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCapsuleComponent");

	Params::BP_Character_C_GetCapsuleComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Capsule != nullptr)
		*Param_Capsule = Parms.Param_Capsule;
}


// Function BP_Character.BP_Character_C.GetCapsuleLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetCapsuleLocation(struct FVector* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCapsuleLocation");

	Params::BP_Character_C_GetCapsuleLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = std::move(Parms.NewParam);
}


// Function BP_Character.BP_Character_C.GetCapsuleLocationFromBase
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          BaseLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ZOffset                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_Character_C::GetCapsuleLocationFromBase(const struct FVector& BaseLocation, double ZOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCapsuleLocationFromBase");

	Params::BP_Character_C_GetCapsuleLocationFromBase Parms{};

	Parms.BaseLocation = std::move(BaseLocation);
	Parms.ZOffset = ZOffset;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetCapsuleRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::GetCapsuleRotation(struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCapsuleRotation");

	Params::BP_Character_C_GetCapsuleRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function BP_Character.BP_Character_C.GetCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ChoosenChar                           Character                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetCharacter(E_ChoosenChar* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCharacter");

	Params::BP_Character_C_GetCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Character != nullptr)
		*Character = Parms.Character;
}


// Function BP_Character.BP_Character_C.GetCharacterVelocity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_Character_C::GetCharacterVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCharacterVelocity");

	Params::BP_Character_C_GetCharacterVelocity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetConnectedChains
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Chains                                                 (Parm, OutParm)

void ABP_Character_C::GetConnectedChains(TArray<class AActor*>* Chains)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetConnectedChains");

	Params::BP_Character_C_GetConnectedChains Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Chains != nullptr)
		*Chains = std::move(Parms.Chains);
}


// Function BP_Character.BP_Character_C.GetCosmeticSocket
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Comp                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetCosmeticSocket(class UPrimitiveComponent** Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCosmeticSocket");

	Params::BP_Character_C_GetCosmeticSocket Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Comp != nullptr)
		*Comp = Parms.Comp;
}


// Function BP_Character.BP_Character_C.GetCurrentVehicle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Vehicle                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetCurrentVehicle(class AActor** Vehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetCurrentVehicle");

	Params::BP_Character_C_GetCurrentVehicle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Vehicle != nullptr)
		*Vehicle = Parms.Vehicle;
}


// Function BP_Character.BP_Character_C.GetDesiredMoveDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Normalize                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RightAxisScale                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_Character_C::GetDesiredMoveDirection(bool Normalize, double RightAxisScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetDesiredMoveDirection");

	Params::BP_Character_C_GetDesiredMoveDirection Parms{};

	Parms.Normalize = Normalize;
	Parms.RightAxisScale = RightAxisScale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetFakeChainSocket
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Socket                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetFakeChainSocket(class USceneComponent** Socket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetFakeChainSocket");

	Params::BP_Character_C_GetFakeChainSocket Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Socket != nullptr)
		*Socket = Parms.Socket;
}


// Function BP_Character.BP_Character_C.GetHandLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetHandLocation(struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetHandLocation");

	Params::BP_Character_C_GetHandLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BP_Character.BP_Character_C.GetIsDetectableByPlacingBlocks
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::GetIsDetectableByPlacingBlocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetIsDetectableByPlacingBlocks");

	Params::BP_Character_C_GetIsDetectableByPlacingBlocks Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetIsDriving
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::GetIsDriving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetIsDriving");

	Params::BP_Character_C_GetIsDriving Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetLastUpdateRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rot                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::GetLastUpdateRotation(struct FRotator* Rot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetLastUpdateRotation");

	Params::BP_Character_C_GetLastUpdateRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Rot != nullptr)
		*Rot = std::move(Parms.Rot);
}


// Function BP_Character.BP_Character_C.GetMantleAsset
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EMantleType                             MantleType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FMantle_Asset                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

struct FMantle_Asset ABP_Character_C::GetMantleAsset(EMantleType MantleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetMantleAsset");

	Params::BP_Character_C_GetMantleAsset Parms{};

	Parms.MantleType = MantleType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetMappedSpeed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_Character_C::GetMappedSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetMappedSpeed");

	Params::BP_Character_C_GetMappedSpeed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.GetMovementState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_MovementState                      State                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetMovementState(EALS_MovementState* State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetMovementState");

	Params::BP_Character_C_GetMovementState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (State != nullptr)
		*State = Parms.State;
}


// Function BP_Character.BP_Character_C.GetSkeletalMesh
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SKM                                                    (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetSkeletalMesh(class USkeletalMeshComponent** SKM)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetSkeletalMesh");

	Params::BP_Character_C_GetSkeletalMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SKM != nullptr)
		*SKM = Parms.SKM;
}


// Function BP_Character.BP_Character_C.GetWalkMagnitude
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Magnitude                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::GetWalkMagnitude(double* Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "GetWalkMagnitude");

	Params::BP_Character_C_GetWalkMagnitude Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Magnitude != nullptr)
		*Magnitude = Parms.Magnitude;
}


// Function BP_Character.BP_Character_C.Handle Movement and Damping
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Handle_Movement_and_Damping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Handle Movement and Damping");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.HandSplash
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    RightHand                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::HandSplash(bool RightHand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "HandSplash");

	Params::BP_Character_C_HandSplash Parms{};

	Parms.RightHand = RightHand;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.HasJustBeginGrounded
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::HasJustBeginGrounded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "HasJustBeginGrounded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.HasJustStopGrounded
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::HasJustStopGrounded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "HasJustStopGrounded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ImproveFail
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ImproveFail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ImproveFail");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Input Leave Tyro
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Input_Leave_Tyro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Input Leave Tyro");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.IsBeingAttracted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Attracted                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::IsBeingAttracted(bool* Attracted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsBeingAttracted");

	Params::BP_Character_C_IsBeingAttracted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Attracted != nullptr)
		*Attracted = Parms.Attracted;
}


// Function BP_Character.BP_Character_C.IsChained
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::IsChained()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsChained");

	Params::BP_Character_C_IsChained Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.IsClimbing
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::IsClimbing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsClimbing");

	Params::BP_Character_C_IsClimbing Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.IsCloseToGround
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::IsCloseToGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsCloseToGround");

	Params::BP_Character_C_IsCloseToGround Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.IsGrounded
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Grounded                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::IsGrounded(bool* Param_Grounded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsGrounded");

	Params::BP_Character_C_IsGrounded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Grounded != nullptr)
		*Param_Grounded = Parms.Param_Grounded;
}


// Function BP_Character.BP_Character_C.IsInCinematicMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::IsInCinematicMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsInCinematicMode");

	Params::BP_Character_C_IsInCinematicMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.IsOnTyrolienne
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::IsOnTyrolienne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsOnTyrolienne");

	Params::BP_Character_C_IsOnTyrolienne Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.IsPulling
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Pulling                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::IsPulling(bool* Pulling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsPulling");

	Params::BP_Character_C_IsPulling Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Pulling != nullptr)
		*Pulling = Parms.Pulling;
}


// Function BP_Character.BP_Character_C.IsSomeoneStuckFalling
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::IsSomeoneStuckFalling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsSomeoneStuckFalling");

	Params::BP_Character_C_IsSomeoneStuckFalling Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.IsSwimming
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Swim                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::IsSwimming(bool* Param_Swim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsSwimming");

	Params::BP_Character_C_IsSwimming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Swim != nullptr)
		*Param_Swim = Parms.Param_Swim;
}


// Function BP_Character.BP_Character_C.IsWalkableSurface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::IsWalkableSurface(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "IsWalkableSurface");

	Params::BP_Character_C_IsWalkableSurface Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.Jump
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Jump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Jump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Jump Input
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Jump_Input()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Jump Input");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.JumpAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::JumpAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "JumpAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.JumpForceFix
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::JumpForceFix()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "JumpForceFix");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.JumpInputAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::JumpInputAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "JumpInputAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.JumpInputServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::JumpInputServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "JumpInputServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.JumpSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::JumpSRV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "JumpSRV");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.JumpTraceHits
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FHitResult>               Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    Good                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::JumpTraceHits(TArray<struct FHitResult>& Array, bool* Good)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "JumpTraceHits");

	Params::BP_Character_C_JumpTraceHits Parms{};

	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Good != nullptr)
		*Good = Parms.Good;
}


// Function BP_Character.BP_Character_C.LaunchChainVolumeVariation
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::LaunchChainVolumeVariation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "LaunchChainVolumeVariation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.LaunchMantleTimeline
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::LaunchMantleTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "LaunchMantleTimeline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.LeaveTyro
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::LeaveTyro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "LeaveTyro");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.LeaveTyroAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::LeaveTyroAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "LeaveTyroAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.LeaveTyroSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::LeaveTyroSRV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "LeaveTyroSRV");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.LimitRotation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  AimYawMin                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  AimYawMax                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  InterpSpeed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::LimitRotation(double AimYawMin, double AimYawMax, double InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "LimitRotation");

	Params::BP_Character_C_LimitRotation Parms{};

	Parms.AimYawMin = AimYawMin;
	Parms.AimYawMax = AimYawMax;
	Parms.InterpSpeed = InterpSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.LookRight
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Axis                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::LookRight(double Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "LookRight");

	Params::BP_Character_C_LookRight Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.LookUp
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Axis                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::LookUp(double Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "LookUp");

	Params::BP_Character_C_LookUp Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MakeBeltFall
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::MakeBeltFall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MakeBeltFall");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.MakeOutline
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Outline                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MakeOutline(bool Outline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MakeOutline");

	Params::BP_Character_C_MakeOutline Parms{};

	Parms.Outline = Outline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MantleCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FMantle_TraceSettings            Trace_Settings                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDrawDebugTrace                         DebugType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Vault                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MantleCheck(const struct FMantle_TraceSettings& Trace_Settings, EDrawDebugTrace DebugType, bool* Vault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleCheck");

	Params::BP_Character_C_MantleCheck Parms{};

	Parms.Trace_Settings = std::move(Trace_Settings);
	Parms.DebugType = DebugType;

	UObject::ProcessEvent(Func, &Parms);

	if (Vault != nullptr)
		*Vault = Parms.Vault;
}


// Function BP_Character.BP_Character_C.MantleCheckShuffle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MantleCheckShuffle(double Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleCheckShuffle");

	Params::BP_Character_C_MantleCheckShuffle Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MantleEnd
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::MantleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.MantleStart
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  MantleHeight                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FALS_ComponentAndTransform       MantleLedgeWS                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// EMantleType                             MantleType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MantleStart(double MantleHeight, const struct FALS_ComponentAndTransform& MantleLedgeWS, EMantleType MantleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleStart");

	Params::BP_Character_C_MantleStart Parms{};

	Parms.MantleHeight = MantleHeight;
	Parms.MantleLedgeWS = std::move(MantleLedgeWS);
	Parms.MantleType = MantleType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MantleStartAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  MantleHeight                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FALS_ComponentAndTransform       MantleLedgeWS                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// EMantleType                             MantleType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MantleStartAll(double MantleHeight, const struct FALS_ComponentAndTransform& MantleLedgeWS, EMantleType MantleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleStartAll");

	Params::BP_Character_C_MantleStartAll Parms{};

	Parms.MantleHeight = MantleHeight;
	Parms.MantleLedgeWS = std::move(MantleLedgeWS);
	Parms.MantleType = MantleType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MantleStartSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  MantleHeight                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FALS_ComponentAndTransform       MantleLedgeWS                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// EMantleType                             MantleType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MantleStartSRV(double MantleHeight, const struct FALS_ComponentAndTransform& MantleLedgeWS, EMantleType MantleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleStartSRV");

	Params::BP_Character_C_MantleStartSRV Parms{};

	Parms.MantleHeight = MantleHeight;
	Parms.MantleLedgeWS = std::move(MantleLedgeWS);
	Parms.MantleType = MantleType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MantleTimeline__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::MantleTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.MantleTimeline__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::MantleTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.MantleUpdate
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  BlendIn                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MantleUpdate(double BlendIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MantleUpdate");

	Params::BP_Character_C_MantleUpdate Parms{};

	Parms.BlendIn = BlendIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveForward
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Axis                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveForward(double Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveForward");

	Params::BP_Character_C_MoveForward Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveForwardSRV
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  MoveForward                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveForwardSRV(double MoveForward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveForwardSRV");

	Params::BP_Character_C_MoveForwardSRV Parms{};

	Parms.MoveForward = MoveForward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveForwardVectorAll
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Param_MoveForwardVector                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveForwardVectorAll(const struct FVector& Param_MoveForwardVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveForwardVectorAll");

	Params::BP_Character_C_MoveForwardVectorAll Parms{};

	Parms.Param_MoveForwardVector = std::move(Param_MoveForwardVector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveForwardVectorSRV
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Param_MoveForwardVector                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveForwardVectorSRV(const struct FVector& Param_MoveForwardVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveForwardVectorSRV");

	Params::BP_Character_C_MoveForwardVectorSRV Parms{};

	Parms.Param_MoveForwardVector = std::move(Param_MoveForwardVector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveRight
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Axis                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveRight(double Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveRight");

	Params::BP_Character_C_MoveRight Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveRightSRV
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  MoveRight                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveRightSRV(double MoveRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveRightSRV");

	Params::BP_Character_C_MoveRightSRV Parms{};

	Parms.MoveRight = MoveRight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveRightVectorAll
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Param_MoveRightVector                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveRightVectorAll(const struct FVector& Param_MoveRightVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveRightVectorAll");

	Params::BP_Character_C_MoveRightVectorAll Parms{};

	Parms.Param_MoveRightVector = std::move(Param_MoveRightVector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveRightVectorSRV
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Param_MoveRightVector                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveRightVectorSRV(const struct FVector& Param_MoveRightVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveRightVectorSRV");

	Params::BP_Character_C_MoveRightVectorSRV Parms{};

	Parms.Param_MoveRightVector = std::move(Param_MoveRightVector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MoveToTyrolienne
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Tyrolienne_C*                 Tyro                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::MoveToTyrolienne(class ABP_Tyrolienne_C* Tyro)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MoveToTyrolienne");

	Params::BP_Character_C_MoveToTyrolienne Parms{};

	Parms.Tyro = Tyro;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.MultiLineTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   X                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Y                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Spacing                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDrawDebugTrace                         DrawDebugType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  DrawTime                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::MultiLineTrace(const struct FVector& Start, const struct FVector& End, int32 X, int32 Y, double Spacing, EDrawDebugTrace DrawDebugType, double DrawTime, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "MultiLineTrace");

	Params::BP_Character_C_MultiLineTrace Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Spacing = Spacing;
	Parms.DrawDebugType = DrawDebugType;
	Parms.DrawTime = DrawTime;

	UObject::ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.NullVelocityTL__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::NullVelocityTL__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "NullVelocityTL__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.NullVelocityTL__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::NullVelocityTL__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "NullVelocityTL__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnGaitChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_Gait                               NewActualGait                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OnGaitChanged(EALS_Gait NewActualGait)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnGaitChanged");

	Params::BP_Character_C_OnGaitChanged Parms{};

	Parms.NewActualGait = NewActualGait;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnMovementActionChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_MovementAction                     NewMovementAction                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OnMovementActionChanged(EALS_MovementAction NewMovementAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnMovementActionChanged");

	Params::BP_Character_C_OnMovementActionChanged Parms{};

	Parms.NewMovementAction = NewMovementAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnMovementStateChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_MovementState                      NewMovementState                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OnMovementStateChanged(EALS_MovementState NewMovementState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnMovementStateChanged");

	Params::BP_Character_C_OnMovementStateChanged Parms{};

	Parms.NewMovementState = NewMovementState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnOverlayStateChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_OverlayState                       NewOverlayState                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OnOverlayStateChanged(EALS_OverlayState NewOverlayState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnOverlayStateChanged");

	Params::BP_Character_C_OnOverlayStateChanged Parms{};

	Parms.NewOverlayState = NewOverlayState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnPossessOwner
// (Net, NetClient, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnPossessOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnPossessOwner");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_FlyMode
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_FlyMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_FlyMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_HasWings
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_HasWings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_HasWings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_Pseudo
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Pseudo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Pseudo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_PullingCharacter
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_PullingCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_PullingCharacter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRep_Rep Attached Characters
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnRep_Rep_Attached_Characters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRep_Rep Attached Characters");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnRotationModeChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_RotationMode                       NewRotationMode                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OnRotationModeChanged(EALS_RotationMode NewRotationMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnRotationModeChanged");

	Params::BP_Character_C_OnRotationModeChanged Parms{};

	Parms.NewRotationMode = NewRotationMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.OnVehicleExit
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::OnVehicleExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnVehicleExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.OnViewModeChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EALS_ViewMode                           NewViewMode                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::OnViewModeChanged(EALS_ViewMode NewViewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "OnViewModeChanged");

	Params::BP_Character_C_OnViewModeChanged Parms{};

	Parms.NewViewMode = NewViewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.PlayClimbSound
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::PlayClimbSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "PlayClimbSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.PlayEffortSound
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Weight                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::PlayEffortSound(float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "PlayEffortSound");

	Params::BP_Character_C_PlayEffortSound Parms{};

	Parms.Weight = Weight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.PlayMantleMontage
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FMantle_Params                   Param_Mantle_Params                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::PlayMantleMontage(const struct FMantle_Params& Param_Mantle_Params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "PlayMantleMontage");

	Params::BP_Character_C_PlayMantleMontage Parms{};

	Parms.Param_Mantle_Params = std::move(Param_Mantle_Params);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.PlayVoiceSRV
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<uint8>                           Data                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ABP_Character_C::PlayVoiceSRV(const TArray<uint8>& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "PlayVoiceSRV");

	Params::BP_Character_C_PlayVoiceSRV Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.PostMantleStabilization
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::PostMantleStabilization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "PostMantleStabilization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ReactivatePhysics
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ReactivatePhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReactivatePhysics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Character_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ReceivePossessed
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      NewController                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ReceivePossessed(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReceivePossessed");

	Params::BP_Character_C_ReceivePossessed Parms{};

	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReceiveTick");

	Params::BP_Character_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.RepControlRotSRV
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         DesiredControlRotation                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::RepControlRotSRV(const struct FRotator& DesiredControlRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "RepControlRotSRV");

	Params::BP_Character_C_RepControlRotSRV Parms{};

	Parms.DesiredControlRotation = std::move(DesiredControlRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.Replicate Location
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Replicate_Location()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Replicate Location");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ReplicateCapsuleRotation
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Param_RepCapsuleYaw                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ReplicateCapsuleRotation(double Param_RepCapsuleYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReplicateCapsuleRotation");

	Params::BP_Character_C_ReplicateCapsuleRotation Parms{};

	Parms.Param_RepCapsuleYaw = Param_RepCapsuleYaw;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ReplicateControlRotation
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ReplicateControlRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReplicateControlRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ReplicatePseudo
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Param_Pseudo                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void ABP_Character_C::ReplicatePseudo(const class FString& Param_Pseudo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReplicatePseudo");

	Params::BP_Character_C_ReplicatePseudo Parms{};

	Parms.Param_Pseudo = std::move(Param_Pseudo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ReplicationCollision_GravityUpdater
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ReplicationCollision_GravityUpdater()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ReplicationCollision_GravityUpdater");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.RescueTeleport
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::RescueTeleport(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "RescueTeleport");

	Params::BP_Character_C_RescueTeleport Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ResetCharacterMass
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ResetCharacterMass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResetCharacterMass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ResetClimb
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ResetClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResetClimb");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ResetClimbingState
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ResetClimbingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResetClimbingState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ResetSkeletalMeshLocation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ResetSkeletalMeshLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResetSkeletalMeshLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ResetStepDownTL
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ResetStepDownTL()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResetStepDownTL");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.RessortImpulse
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Impulse                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::RessortImpulse(const struct FVector& Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "RessortImpulse");

	Params::BP_Character_C_RessortImpulse Parms{};

	Parms.Impulse = std::move(Impulse);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ResyncDetection(Grounded)
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ResyncDetection_Grounded_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResyncDetection(Grounded)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ResyncTimeline__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::ResyncTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResyncTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ResyncTimeline__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::ResyncTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ResyncTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SelectControlRot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FRotator                         DesiredControlRotation                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::SelectControlRot(struct FRotator* DesiredControlRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SelectControlRot");

	Params::BP_Character_C_SelectControlRot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DesiredControlRotation != nullptr)
		*DesiredControlRotation = std::move(Parms.DesiredControlRotation);
}


// Function BP_Character.BP_Character_C.SelectMoveForwardAxis
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_Character_C::SelectMoveForwardAxis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SelectMoveForwardAxis");

	Params::BP_Character_C_SelectMoveForwardAxis Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.SelectMoveRightAxis
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_Character_C::SelectMoveRightAxis()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SelectMoveRightAxis");

	Params::BP_Character_C_SelectMoveRightAxis Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.SelectVelocity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_Character_C::SelectVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SelectVelocity");

	Params::BP_Character_C_SelectVelocity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.SetActorLocationAndRotation(UpdateTarget)
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          NewLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         NewRotation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bSweep                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bTeleport                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::SetActorLocationAndRotation_UpdateTarget_(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FHitResult* SweepHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetActorLocationAndRotation(UpdateTarget)");

	Params::BP_Character_C_SetActorLocationAndRotation_UpdateTarget_ Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.SetCameraRotation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::SetCameraRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetCameraRotation");

	Params::BP_Character_C_SetCameraRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetChainComp
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMeshComponent*             Comp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetChainComp(class UStaticMeshComponent* Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetChainComp");

	Params::BP_Character_C_SetChainComp Parms{};

	Parms.Comp = Comp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetCharacterRotation
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::SetCharacterRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetCharacterRotation");

	Params::BP_Character_C_SetCharacterRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetCharacterVelocity
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          NewVel                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Capsule                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Sphere                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetCharacterVelocity(const struct FVector& NewVel, bool Param_Capsule, bool Param_Sphere)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetCharacterVelocity");

	Params::BP_Character_C_SetCharacterVelocity Parms{};

	Parms.NewVel = std::move(NewVel);
	Parms.Param_Capsule = Param_Capsule;
	Parms.Param_Sphere = Param_Sphere;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetCollisionResponse
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECollisionChannel                       Collision                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ECollisionResponse                      Response                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetCollisionResponse(ECollisionChannel Collision, ECollisionResponse Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetCollisionResponse");

	Params::BP_Character_C_SetCollisionResponse Parms{};

	Parms.Collision = Collision;
	Parms.Response = Response;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetController
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetController(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetController");

	Params::BP_Character_C_SetController Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetCosmeticChainFixSocket
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Socket                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FName                             Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetCosmeticChainFixSocket(class UPrimitiveComponent* Socket, class FName Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetCosmeticChainFixSocket");

	Params::BP_Character_C_SetCosmeticChainFixSocket Parms{};

	Parms.Socket = Socket;
	Parms.Param_Name = Param_Name;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetEssentialValues
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SetEssentialValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetEssentialValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SetFlyMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_FlyMode                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetFlyMode(bool Param_FlyMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetFlyMode");

	Params::BP_Character_C_SetFlyMode Parms{};

	Parms.Param_FlyMode = Param_FlyMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetInAirDamping
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Damping                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetInAirDamping(double Damping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetInAirDamping");

	Params::BP_Character_C_SetInAirDamping Parms{};

	Parms.Damping = Damping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetIsDetectableByPlacingBlocks
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Detectable                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetIsDetectableByPlacingBlocks(bool Detectable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetIsDetectableByPlacingBlocks");

	Params::BP_Character_C_SetIsDetectableByPlacingBlocks Parms{};

	Parms.Detectable = Detectable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetIsDriving
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Driving                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetIsDriving(bool Driving)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetIsDriving");

	Params::BP_Character_C_SetIsDriving Parms{};

	Parms.Driving = Driving;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetIsInMovingObject
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_InMovingObject                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetIsInMovingObject(bool Param_InMovingObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetIsInMovingObject");

	Params::BP_Character_C_SetIsInMovingObject Parms{};

	Parms.Param_InMovingObject = Param_InMovingObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetIsSwimming
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Swim                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetIsSwimming(bool Param_Swim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetIsSwimming");

	Params::BP_Character_C_SetIsSwimming Parms{};

	Parms.Param_Swim = Param_Swim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetLookAround
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LookAround                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetLookAround(bool LookAround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetLookAround");

	Params::BP_Character_C_SetLookAround Parms{};

	Parms.LookAround = LookAround;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetPawnMovementMode
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EMovementMode                           Param_Pawn_Movement_Mode                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetPawnMovementMode(EMovementMode Param_Pawn_Movement_Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetPawnMovementMode");

	Params::BP_Character_C_SetPawnMovementMode Parms{};

	Parms.Param_Pawn_Movement_Mode = Param_Pawn_Movement_Mode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetPlayerNameSRV
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           PlayerName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void ABP_Character_C::SetPlayerNameSRV(const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetPlayerNameSRV");

	Params::BP_Character_C_SetPlayerNameSRV Parms{};

	Parms.PlayerName = std::move(PlayerName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetRenderCustomDepth
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bValue                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetRenderCustomDepth(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetRenderCustomDepth");

	Params::BP_Character_C_SetRenderCustomDepth Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetRotation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Character_C::SetRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetRotation");

	Params::BP_Character_C_SetRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SetZLocation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Z                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SetZLocation(double Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SetZLocation");

	Params::BP_Character_C_SetZLocation Parms{};

	Parms.Z = Z;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ShowHidePullWidget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Show                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ShowHidePullWidget(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShowHidePullWidget");

	Params::BP_Character_C_ShowHidePullWidget Parms{};

	Parms.Show = Show;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ShuffleAirControl
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ShuffleAirControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShuffleAirControl");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ShuffleFixToGround
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ShuffleFixToGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShuffleFixToGround");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ShuffleHardSnap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ShuffleHardSnap(double Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShuffleHardSnap");

	Params::BP_Character_C_ShuffleHardSnap Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ShuffleHardSnapping
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ShuffleHardSnapping(double Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShuffleHardSnapping");

	Params::BP_Character_C_ShuffleHardSnapping Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ShuffleMantleCheck
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ShuffleMantleCheck(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShuffleMantleCheck");

	Params::BP_Character_C_ShuffleMantleCheck Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ShufflePullStabilization
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ShufflePullStabilization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShufflePullStabilization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.ShufflePushedByObstacle
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ShufflePushedByObstacle(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShufflePushedByObstacle");

	Params::BP_Character_C_ShufflePushedByObstacle Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ShuffleReplicationScale
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  NullDuration                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TimelineDuration                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::ShuffleReplicationScale(double NullDuration, double TimelineDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShuffleReplicationScale");

	Params::BP_Character_C_ShuffleReplicationScale Parms{};

	Parms.NullDuration = NullDuration;
	Parms.TimelineDuration = TimelineDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.ShuffleSliding
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::ShuffleSliding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "ShuffleSliding");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SimulateGravity
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SimulateGravity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SimulateGravity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SimulateLegsPhysics
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bNewSimulate                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  PhysicsBlendWeight                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SimulateLegsPhysics(bool bNewSimulate, double PhysicsBlendWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SimulateLegsPhysics");

	Params::BP_Character_C_SimulateLegsPhysics Parms{};

	Parms.bNewSimulate = bNewSimulate;
	Parms.PhysicsBlendWeight = PhysicsBlendWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SmoothCharacterRotation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double                                  TargetInterpSpeed_Const_                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ActorInterpSpeed_Smooth_                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SmoothCharacterRotation(const struct FRotator& Target, double TargetInterpSpeed_Const_, double ActorInterpSpeed_Smooth_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SmoothCharacterRotation");

	Params::BP_Character_C_SmoothCharacterRotation Parms{};

	Parms.Target = std::move(Target);
	Parms.TargetInterpSpeed_Const_ = TargetInterpSpeed_Const_;
	Parms.ActorInterpSpeed_Smooth_ = ActorInterpSpeed_Smooth_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SnapCharacterToVehicle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USphereComponent*                 DriverSocket                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SnapCharacterToVehicle(class USphereComponent* DriverSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SnapCharacterToVehicle");

	Params::BP_Character_C_SnapCharacterToVehicle Parms{};

	Parms.DriverSocket = DriverSocket;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.Spawn Chains
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Spawn_Chains()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Spawn Chains");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SpawnChainsServer
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SpawnChainsServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SpawnChainsServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SpawnStabilisationSocket
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SpawnStabilisationSocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SpawnStabilisationSocket");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Sprint
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Sprint                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::Sprint(bool Param_Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Sprint");

	Params::BP_Character_C_Sprint Parms{};

	Parms.Param_Sprint = Param_Sprint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SprintAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Sprint                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SprintAll(bool Param_Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SprintAll");

	Params::BP_Character_C_SprintAll Parms{};

	Parms.Param_Sprint = Param_Sprint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SprintSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_Sprint                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SprintSRV(bool Param_Sprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SprintSRV");

	Params::BP_Character_C_SprintSRV Parms{};

	Parms.Param_Sprint = Param_Sprint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.StabilizeGroundedMovement
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StabilizeGroundedMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StabilizeGroundedMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Stance
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Stance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Stance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StepDownTL
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StepDownTL()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StepDownTL");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StepMovement
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StepMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StepMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SteppingDownBoolTL__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::SteppingDownBoolTL__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SteppingDownBoolTL__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SteppingDownBoolTL__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::SteppingDownBoolTL__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SteppingDownBoolTL__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SteppingUpTL
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SteppingUpTL()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SteppingUpTL");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SteppUpBoolTL__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::SteppUpBoolTL__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SteppUpBoolTL__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SteppUpBoolTL__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::SteppUpBoolTL__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SteppUpBoolTL__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StopClimbAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StopClimbAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StopClimbAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StopFalldown
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StopFalldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StopFalldown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StopFlotterAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StopFlotterAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StopFlotterAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StopFlotterSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StopFlotterSRV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StopFlotterSRV");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StopGridConstraint
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StopGridConstraint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StopGridConstraint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StopMantleTimeline
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StopMantleTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StopMantleTimeline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StopUnstuck
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::StopUnstuck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StopUnstuck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.StuckTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

bool ABP_Character_C::StuckTrace(struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "StuckTrace");

	Params::BP_Character_C_StuckTrace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function BP_Character.BP_Character_C.SunAttraction
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::SunAttraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SunAttraction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.SwitchClimbMode
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Rot                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class USceneComponent*                  Comp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SwitchClimbMode(const struct FRotator& Rot, class USceneComponent* Comp, const struct FVector& HitLocation, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SwitchClimbMode");

	Params::BP_Character_C_SwitchClimbMode Parms{};

	Parms.Rot = std::move(Rot);
	Parms.Comp = Comp;
	Parms.HitLocation = std::move(HitLocation);
	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SwitchToTyroAll
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Tyrolienne_C*                 Tyrolienne                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SwitchToTyroAll(class ABP_Tyrolienne_C* Tyrolienne)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SwitchToTyroAll");

	Params::BP_Character_C_SwitchToTyroAll Parms{};

	Parms.Tyrolienne = Tyrolienne;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SwitchToTyrolienne
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Tyrolienne_C*                 Tyrolienne                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SwitchToTyrolienne(class ABP_Tyrolienne_C* Tyrolienne)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SwitchToTyrolienne");

	Params::BP_Character_C_SwitchToTyrolienne Parms{};

	Parms.Tyrolienne = Tyrolienne;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.SwitchToTyroSRV
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Tyrolienne_C*                 Tyrolienne                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::SwitchToTyroSRV(class ABP_Tyrolienne_C* Tyrolienne)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "SwitchToTyroSRV");

	Params::BP_Character_C_SwitchToTyroSRV Parms{};

	Parms.Tyrolienne = Tyrolienne;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.TestControlNotify
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::TestControlNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "TestControlNotify");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_0__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_0__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_0__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_0__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_0__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_0__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_10__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_10__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_10__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_10__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_10__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_10__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_11__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_11__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_11__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_11__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_11__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_11__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_12__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_12__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_12__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_12__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_12__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_12__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_1__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_1__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_1__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_1__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_1__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_1__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_2__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_2__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_2__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_2__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_2__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_2__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_3__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_3__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_3__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_3__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_3__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_3__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_4__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_4__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_4__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_4__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_4__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_4__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_5__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_5__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_5__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_5__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_5__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_5__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_6__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_6__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_6__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_6__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_6__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_6__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_7__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_7__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_7__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_7__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_7__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_7__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_8__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_8__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_8__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_8__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_8__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_8__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_9__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_9__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_9__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline_9__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline_9__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline_9__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline__FinishedFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Timeline__UpdateFunc
// (BlueprintEvent)

void ABP_Character_C::Timeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Timeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.TrampolineBounce
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_Instigator                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseControlRot                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::TrampolineBounce(double Force, bool Param_Instigator, bool UseControlRot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "TrampolineBounce");

	Params::BP_Character_C_TrampolineBounce Parms{};

	Parms.Force = Force;
	Parms.Param_Instigator = Param_Instigator;
	Parms.UseControlRot = UseControlRot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.TryUnstuck
// (BlueprintCallable, BlueprintEvent)

void ABP_Character_C::TryUnstuck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "TryUnstuck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UnderLava
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UnderLava()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UnderLava");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.Update Balancier Arrow Rotation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::Update_Balancier_Arrow_Rotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "Update Balancier Arrow Rotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateChainSound
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateChainSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateChainSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateCharacterMovement
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateCharacterMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateCharacterMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateDecceleration
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateDecceleration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateDecceleration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateDriveHands
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Left                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Right                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Character_C::UpdateDriveHands(const struct FVector& Left, const struct FVector& Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateDriveHands");

	Params::BP_Character_C_UpdateDriveHands Parms{};

	Parms.Left = std::move(Left);
	Parms.Right = std::move(Right);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Character.BP_Character_C.UpdateGroudedRotation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateGroudedRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateGroudedRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateMovementState
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateMovementState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateMovementState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateMoveVectors
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateMoveVectors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateMoveVectors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateServerReconciliationSpeed
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateServerReconciliationSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateServerReconciliationSpeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateSpringArmSpeed
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateSpringArmSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateSpringArmSpeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateSwimRotation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateSwimRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateSwimRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UpdateTyrolienneHands
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UpdateTyrolienneHands()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UpdateTyrolienneHands");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Character_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Character.BP_Character_C.VerifyChainTendue
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double                                  Tension                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Character_C::VerifyChainTendue(TArray<class AActor*>& Array, double Tension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Character_C", "VerifyChainTendue");

	Params::BP_Character_C_VerifyChainTendue Parms{};

	Parms.Array = std::move(Array);
	Parms.Tension = Tension;

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	return Parms.ReturnValue;
}

}

