#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: WM_InputManager_Plugin

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "WM_InputManager_Plugin_structs.hpp"
#include "InputCore_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class WM_InputManager_Plugin.WM_ControllerFunctionLib
// 0x0000 (0x0028 - 0x0028)
class UWM_ControllerFunctionLib final : public UBlueprintFunctionLibrary
{
public:
	static class UWM_InputManager* Get_WM_InputManager();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_ControllerFunctionLib">();
	}
	static class UWM_ControllerFunctionLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_ControllerFunctionLib>();
	}
};
static_assert(alignof(UWM_ControllerFunctionLib) == 0x000008, "Wrong alignment on UWM_ControllerFunctionLib");
static_assert(sizeof(UWM_ControllerFunctionLib) == 0x000028, "Wrong size on UWM_ControllerFunctionLib");

// Class WM_InputManager_Plugin.WM_Device
// 0x00F8 (0x0120 - 0x0028)
class UWM_Device : public UObject
{
public:
	uint8                                         Pad_1C7C[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWM_BasicDeviceInfo                    BasicDeviceInfo;                                   // 0x0038(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRawDataInitialized;                              // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RawDataWasInitialized;                             // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C7D[0x6];                                     // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SAVESTRING;                                        // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWM_DeviceType                                DeviceType;                                        // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C7E[0x3];                                     // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeviceSlot;                                        // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UniqueDeviceSlot;                                  // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerAssigment;                               // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerAssigment_pending;                       // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DeviceActivityDetected;                            // 0x00DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSelected;                                        // 0x00DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C7F[0x2A];                                    // 0x00DE(0x002A)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UniqueHandleString;                                // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PacketNum;                                         // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C80[0x4];                                     // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignDeviceToPlayerIndex(int32 Param_Index);
	void ClearDeviceInput();
	bool IsValidPlayerIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Device">();
	}
	static class UWM_Device* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Device>();
	}
};
static_assert(alignof(UWM_Device) == 0x000008, "Wrong alignment on UWM_Device");
static_assert(sizeof(UWM_Device) == 0x000120, "Wrong size on UWM_Device");
static_assert(offsetof(UWM_Device, BasicDeviceInfo) == 0x000038, "Member 'UWM_Device::BasicDeviceInfo' has a wrong offset!");
static_assert(offsetof(UWM_Device, OnRawDataInitialized) == 0x0000A0, "Member 'UWM_Device::OnRawDataInitialized' has a wrong offset!");
static_assert(offsetof(UWM_Device, Enabled) == 0x0000B0, "Member 'UWM_Device::Enabled' has a wrong offset!");
static_assert(offsetof(UWM_Device, RawDataWasInitialized) == 0x0000B1, "Member 'UWM_Device::RawDataWasInitialized' has a wrong offset!");
static_assert(offsetof(UWM_Device, SAVESTRING) == 0x0000B8, "Member 'UWM_Device::SAVESTRING' has a wrong offset!");
static_assert(offsetof(UWM_Device, DeviceType) == 0x0000C8, "Member 'UWM_Device::DeviceType' has a wrong offset!");
static_assert(offsetof(UWM_Device, DeviceSlot) == 0x0000CC, "Member 'UWM_Device::DeviceSlot' has a wrong offset!");
static_assert(offsetof(UWM_Device, UniqueDeviceSlot) == 0x0000D0, "Member 'UWM_Device::UniqueDeviceSlot' has a wrong offset!");
static_assert(offsetof(UWM_Device, ControllerAssigment) == 0x0000D4, "Member 'UWM_Device::ControllerAssigment' has a wrong offset!");
static_assert(offsetof(UWM_Device, ControllerAssigment_pending) == 0x0000D8, "Member 'UWM_Device::ControllerAssigment_pending' has a wrong offset!");
static_assert(offsetof(UWM_Device, DeviceActivityDetected) == 0x0000DC, "Member 'UWM_Device::DeviceActivityDetected' has a wrong offset!");
static_assert(offsetof(UWM_Device, IsSelected) == 0x0000DD, "Member 'UWM_Device::IsSelected' has a wrong offset!");
static_assert(offsetof(UWM_Device, UniqueHandleString) == 0x000108, "Member 'UWM_Device::UniqueHandleString' has a wrong offset!");
static_assert(offsetof(UWM_Device, PacketNum) == 0x000118, "Member 'UWM_Device::PacketNum' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_Device_HID
// 0x0688 (0x07A8 - 0x0120)
class UWM_Device_HID : public UWM_Device
{
public:
	struct FWM_HID_DeviceInfo                     DeviceInfo;                                        // 0x0120(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          Is_XInput;                                         // 0x01C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_XInputInitialized;                              // 0x01C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_XInputSlotGuess;                                // 0x01C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C81[0x1];                                     // 0x01C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         X_I_D;                                             // 0x01C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Steam;                                          // 0x01C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C82[0x5D7];                                   // 0x01C9(0x05D7)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FirstPressedRawKey;                                // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C83[0x4];                                     // 0x07A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<int32> GetRaw_Available_Axes();
	TArray<int32> GetRaw_Available_Buttons();
	TArray<int32> GetRaw_Available_DPADs();
	void GetRaw_ButtonValue(int32 Param_Index, bool* ButtonValue, EWM_KeyTriggerState* KeyTriggerState);

	void GetAxisKeyValue(const struct FKey& Key, float* AxisValue, bool* IsValid_WM_Key) const;
	void GetButtonKeyValue(const struct FKey& Key, bool* ButtonValue, bool* IsValid_WM_Key) const;
	struct FWM_HID_AxisData GetRaw_AxisData(int32 Param_Index) const;
	float GetRaw_AxisValue(int32 Param_Index) const;
	void GetRaw_DPADData(int32 Param_Index, bool* Up, bool* Down, bool* Left, bool* Right, EWM_AxisCodeTable* AxisEnum, class FString* AxisBindingCode, class FString* AxisHEX, int32* Instance, float* Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Device_HID">();
	}
	static class UWM_Device_HID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Device_HID>();
	}
};
static_assert(alignof(UWM_Device_HID) == 0x000008, "Wrong alignment on UWM_Device_HID");
static_assert(sizeof(UWM_Device_HID) == 0x0007A8, "Wrong size on UWM_Device_HID");
static_assert(offsetof(UWM_Device_HID, DeviceInfo) == 0x000120, "Member 'UWM_Device_HID::DeviceInfo' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, Is_XInput) == 0x0001C0, "Member 'UWM_Device_HID::Is_XInput' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, Is_XInputInitialized) == 0x0001C1, "Member 'UWM_Device_HID::Is_XInputInitialized' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, Is_XInputSlotGuess) == 0x0001C2, "Member 'UWM_Device_HID::Is_XInputSlotGuess' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, X_I_D) == 0x0001C4, "Member 'UWM_Device_HID::X_I_D' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, Is_Steam) == 0x0001C8, "Member 'UWM_Device_HID::Is_Steam' has a wrong offset!");
static_assert(offsetof(UWM_Device_HID, FirstPressedRawKey) == 0x0007A0, "Member 'UWM_Device_HID::FirstPressedRawKey' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_Device_Keyboard
// 0x0000 (0x0120 - 0x0120)
class UWM_Device_Keyboard final : public UWM_Device
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Device_Keyboard">();
	}
	static class UWM_Device_Keyboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Device_Keyboard>();
	}
};
static_assert(alignof(UWM_Device_Keyboard) == 0x000008, "Wrong alignment on UWM_Device_Keyboard");
static_assert(sizeof(UWM_Device_Keyboard) == 0x000120, "Wrong size on UWM_Device_Keyboard");

// Class WM_InputManager_Plugin.WM_Device_Mouse
// 0x0000 (0x0120 - 0x0120)
class UWM_Device_Mouse final : public UWM_Device
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Device_Mouse">();
	}
	static class UWM_Device_Mouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Device_Mouse>();
	}
};
static_assert(alignof(UWM_Device_Mouse) == 0x000008, "Wrong alignment on UWM_Device_Mouse");
static_assert(sizeof(UWM_Device_Mouse) == 0x000120, "Wrong size on UWM_Device_Mouse");

// Class WM_InputManager_Plugin.WM_HID_Joystick
// 0x0068 (0x0810 - 0x07A8)
class UWM_HID_Joystick final : public UWM_Device_HID
{
public:
	uint8                                         Pad_1C89[0x18];                                    // 0x07A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConfigMode;                                        // 0x07C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8A[0x4];                                     // 0x07C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnModeSwitched;                                    // 0x07C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConfigChanged;                                   // 0x07D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsListeningForInput;                              // 0x07E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8B[0x7];                                     // 0x07E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   ListeningKey;                                      // 0x07F0(0x0018)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8C[0x8];                                     // 0x0808(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutodetectAxisConfig(int32 Axis);
	void Bind_InputKey(const struct FKey& Key, const class FString& TargetBinding);
	void GetAxisConfig(int32 AxisNumber, struct FWM_HID_AxisConfiguration* Config);
	void GetBinding(const struct FKey& Key, class FString* Binding);
	void GetBindingOptions(const struct FKey& Key, TArray<class FString>* Options);
	void GetConfigurationMode(int32* ConfigurationMode);
	void ListenForKeyInput(const struct FKey& Key, bool* Sucess);
	void PressButton(int32 Button);
	void RebindKeyInput(const struct FKey& Key, bool* Sucess);
	void ResetAxisConfig(int32 Axis);
	void ResetConfigurationMode();
	void SaveConfig();
	void SetAxisConfig(int32 AxisNumber, const struct FWM_HID_AxisConfiguration& Config);
	void SetConfigurationMode(int32 ConfigurationMode);
	void UpdateAxisValue(int32 Axis);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_HID_Joystick">();
	}
	static class UWM_HID_Joystick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_HID_Joystick>();
	}
};
static_assert(alignof(UWM_HID_Joystick) == 0x000008, "Wrong alignment on UWM_HID_Joystick");
static_assert(sizeof(UWM_HID_Joystick) == 0x000810, "Wrong size on UWM_HID_Joystick");
static_assert(offsetof(UWM_HID_Joystick, ConfigMode) == 0x0007C0, "Member 'UWM_HID_Joystick::ConfigMode' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, OnModeSwitched) == 0x0007C8, "Member 'UWM_HID_Joystick::OnModeSwitched' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, OnConfigChanged) == 0x0007D8, "Member 'UWM_HID_Joystick::OnConfigChanged' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, bIsListeningForInput) == 0x0007E8, "Member 'UWM_HID_Joystick::bIsListeningForInput' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick, ListeningKey) == 0x0007F0, "Member 'UWM_HID_Joystick::ListeningKey' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_HID_Joystick_SAV
// 0x0078 (0x00A0 - 0x0028)
class UWM_HID_Joystick_SAV final : public USaveGame
{
public:
	uint8                                         Pad_1C8F[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WasInitialized;                                    // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C90[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SaveSlot;                                          // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentMode;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C91[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FHID_Joystick_CONFIG>      HID_JoystickConfig;                                // 0x0050(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_HID_Joystick_SAV">();
	}
	static class UWM_HID_Joystick_SAV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_HID_Joystick_SAV>();
	}
};
static_assert(alignof(UWM_HID_Joystick_SAV) == 0x000008, "Wrong alignment on UWM_HID_Joystick_SAV");
static_assert(sizeof(UWM_HID_Joystick_SAV) == 0x0000A0, "Wrong size on UWM_HID_Joystick_SAV");
static_assert(offsetof(UWM_HID_Joystick_SAV, WasInitialized) == 0x000030, "Member 'UWM_HID_Joystick_SAV::WasInitialized' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick_SAV, SaveSlot) == 0x000038, "Member 'UWM_HID_Joystick_SAV::SaveSlot' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick_SAV, CurrentMode) == 0x000048, "Member 'UWM_HID_Joystick_SAV::CurrentMode' has a wrong offset!");
static_assert(offsetof(UWM_HID_Joystick_SAV, HID_JoystickConfig) == 0x000050, "Member 'UWM_HID_Joystick_SAV::HID_JoystickConfig' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_InputManagerBase
// 0x0408 (0x0430 - 0x0028)
class UWM_InputManagerBase : public UObject
{
public:
	uint8                                         Pad_1C92[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEnhancedInputMapping_WM>       EnhancedMappings;                                  // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Version;                                           // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C93[0x20];                                    // 0x0058(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableErrorLogs;                                  // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSucessLogs;                                 // 0x0079(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable_LOG_DEBUG_HIDP_PARSING;                    // 0x007A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollectRuntimeLogs;                               // 0x007B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C94[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Runtime_PluginErrors;                              // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Runtime_PluginSucess;                              // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDevicesRegistered;                                // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C95[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumMessageAttempts;                                // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumFoundJoysticks_Debug;                           // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPoolingDevices;                                 // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWindows;                                        // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C96[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             Debug;                                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C97[0x10];                                    // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EWM_InputManagerMode                          ManagerModeEnum;                                   // 0x00D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSViewport;                                      // 0x00D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C98[0x6];                                     // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDeviceConnected;                                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeviceDisconnected;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJoystickButtonTrigger;                           // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNumDevicesChanged;                               // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeviceSelected;                                  // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnButtonKeyPressed;                                // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnButtonKeyReleased;                               // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSwitchManagerMode;                               // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSwitchManagerModeEnum;                           // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetNumberOfPlayers;                              // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             On_WM_InputManagerBegin;                           // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             On_WM_InputManagerEnd;                             // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnListenForKeyInput;                               // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeviceAssigmentChange;                           // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 ManagerMode;                                       // 0x01C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfPlayers;                                   // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C99[0x1C];                                    // 0x01D4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWM_Device*>                     All_DevicesList;                                   // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_Device_HID*>            HID_DeviceList;                                    // 0x0200(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_HID_Joystick*>          Joystick_DeviceList;                               // 0x0250(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_Device_Keyboard*>       Keyboard_DevicesList;                              // 0x02A0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_Device*>                Mouse_DeviceList;                                  // 0x02F0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_HID_Joystick*>          Joystick_UniqueDeviceTypeList;                     // 0x0340(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, class UWM_Device_HID*>            XInputDevices;                                     // 0x0390(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9A[0x50];                                    // 0x03E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetActionInputs(TArray<class FName>* ButtonInputs);
	void GetActionsListStringForKey(const struct FKey& Key, class FString* ActionsListString);
	void GetAllInputBindingsForKey(const struct FKey& Key, TArray<class FName>* ActionsForKey);
	void GetAllKeysForAction(class FName ActionName, TArray<struct FKey>* Bindings);
	void GetAllKeysForAxis(class FName ActionName, TArray<struct FKey>* Bindings);
	void GetAxisInputs(TArray<class FName>* InputAxisActions);
	void InitializeAPI();
	void OnDeviceButtonKeyEvent(const struct FKey& WM_Key, class UWM_Device* Device, EWM_KeyTriggerState* TriggerState);
	void SetEnchancedInputContext(class UInputMappingContext* InputMappingContext);
	void SetNumberOfPlayers(int32 NumPlayers);
	void SwitchManagerMode(const class FString& Mode);
	void SwitchManagerModeEnum(EWM_InputManagerMode Mode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_InputManagerBase">();
	}
	static class UWM_InputManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_InputManagerBase>();
	}
};
static_assert(alignof(UWM_InputManagerBase) == 0x000008, "Wrong alignment on UWM_InputManagerBase");
static_assert(sizeof(UWM_InputManagerBase) == 0x000430, "Wrong size on UWM_InputManagerBase");
static_assert(offsetof(UWM_InputManagerBase, EnhancedMappings) == 0x000038, "Member 'UWM_InputManagerBase::EnhancedMappings' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Version) == 0x000048, "Member 'UWM_InputManagerBase::Version' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bEnableErrorLogs) == 0x000078, "Member 'UWM_InputManagerBase::bEnableErrorLogs' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bEnableSucessLogs) == 0x000079, "Member 'UWM_InputManagerBase::bEnableSucessLogs' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bEnable_LOG_DEBUG_HIDP_PARSING) == 0x00007A, "Member 'UWM_InputManagerBase::bEnable_LOG_DEBUG_HIDP_PARSING' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bCollectRuntimeLogs) == 0x00007B, "Member 'UWM_InputManagerBase::bCollectRuntimeLogs' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Runtime_PluginErrors) == 0x000080, "Member 'UWM_InputManagerBase::Runtime_PluginErrors' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Runtime_PluginSucess) == 0x000090, "Member 'UWM_InputManagerBase::Runtime_PluginSucess' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, bDevicesRegistered) == 0x0000A0, "Member 'UWM_InputManagerBase::bDevicesRegistered' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumMessageAttempts) == 0x0000A4, "Member 'UWM_InputManagerBase::NumMessageAttempts' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumFoundJoysticks_Debug) == 0x0000A8, "Member 'UWM_InputManagerBase::NumFoundJoysticks_Debug' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumPoolingDevices) == 0x0000AC, "Member 'UWM_InputManagerBase::NumPoolingDevices' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumWindows) == 0x0000B0, "Member 'UWM_InputManagerBase::NumWindows' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Debug) == 0x0000B8, "Member 'UWM_InputManagerBase::Debug' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, ManagerModeEnum) == 0x0000D8, "Member 'UWM_InputManagerBase::ManagerModeEnum' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, HasSViewport) == 0x0000D9, "Member 'UWM_InputManagerBase::HasSViewport' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnDeviceConnected) == 0x0000E0, "Member 'UWM_InputManagerBase::OnDeviceConnected' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnDeviceDisconnected) == 0x0000F0, "Member 'UWM_InputManagerBase::OnDeviceDisconnected' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnJoystickButtonTrigger) == 0x000100, "Member 'UWM_InputManagerBase::OnJoystickButtonTrigger' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnNumDevicesChanged) == 0x000110, "Member 'UWM_InputManagerBase::OnNumDevicesChanged' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnDeviceSelected) == 0x000120, "Member 'UWM_InputManagerBase::OnDeviceSelected' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnButtonKeyPressed) == 0x000130, "Member 'UWM_InputManagerBase::OnButtonKeyPressed' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnButtonKeyReleased) == 0x000140, "Member 'UWM_InputManagerBase::OnButtonKeyReleased' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnSwitchManagerMode) == 0x000150, "Member 'UWM_InputManagerBase::OnSwitchManagerMode' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnSwitchManagerModeEnum) == 0x000160, "Member 'UWM_InputManagerBase::OnSwitchManagerModeEnum' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnSetNumberOfPlayers) == 0x000170, "Member 'UWM_InputManagerBase::OnSetNumberOfPlayers' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, On_WM_InputManagerBegin) == 0x000180, "Member 'UWM_InputManagerBase::On_WM_InputManagerBegin' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, On_WM_InputManagerEnd) == 0x000190, "Member 'UWM_InputManagerBase::On_WM_InputManagerEnd' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnListenForKeyInput) == 0x0001A0, "Member 'UWM_InputManagerBase::OnListenForKeyInput' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, OnDeviceAssigmentChange) == 0x0001B0, "Member 'UWM_InputManagerBase::OnDeviceAssigmentChange' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, ManagerMode) == 0x0001C0, "Member 'UWM_InputManagerBase::ManagerMode' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, NumberOfPlayers) == 0x0001D0, "Member 'UWM_InputManagerBase::NumberOfPlayers' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, All_DevicesList) == 0x0001F0, "Member 'UWM_InputManagerBase::All_DevicesList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, HID_DeviceList) == 0x000200, "Member 'UWM_InputManagerBase::HID_DeviceList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Joystick_DeviceList) == 0x000250, "Member 'UWM_InputManagerBase::Joystick_DeviceList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Keyboard_DevicesList) == 0x0002A0, "Member 'UWM_InputManagerBase::Keyboard_DevicesList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Mouse_DeviceList) == 0x0002F0, "Member 'UWM_InputManagerBase::Mouse_DeviceList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, Joystick_UniqueDeviceTypeList) == 0x000340, "Member 'UWM_InputManagerBase::Joystick_UniqueDeviceTypeList' has a wrong offset!");
static_assert(offsetof(UWM_InputManagerBase, XInputDevices) == 0x000390, "Member 'UWM_InputManagerBase::XInputDevices' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_InputManager
// 0x0318 (0x0748 - 0x0430)
class UWM_InputManager final : public UWM_InputManagerBase
{
public:
	uint8                                         Pad_1C9C[0xF8];                                    // 0x0430(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FKey, EWM_GamepadKeyType>         HIDJoystick_KeysByType;                            // 0x0528(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FKey, class FString>              HIDJoystick_Axes;                                  // 0x0578(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FKey, class FString>              HIDJoystick_Buttons;                               // 0x05C8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FDPADCollection>   HIDJoystick_DPADs;                                 // 0x0618(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9D[0xA0];                                    // 0x0668(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EnableHIDInternalButtonEvents;                     // 0x0708(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWM_InputManagerStatus                        Status;                                            // 0x0709(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9E[0x2];                                     // 0x070A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumGamepads;                                       // 0x070C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumKeyboards;                                      // 0x0710(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumMouses;                                         // 0x0714(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoAssignDevicesByDeviceSlot;                     // 0x0718(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9F[0x14];                                    // 0x071C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowOnlyUsedInputs;                                // 0x0730(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA0[0x17];                                    // 0x0731(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginUMG();
	EWM_GamepadKeyType Get_HidJoystickKeyType(const struct FKey& Key);
	class FString GetCurrentProfileName();
	class UWM_Device* GetSelectedDevice();
	class UWM_HID_Joystick* GetSelectedGamepad();
	void LoadProfile(const class FString& ProfileName);
	void OpenSupportWebsite();
	void SelectDevice(class UWM_Device* DeviceToSelect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_InputManager">();
	}
	static class UWM_InputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_InputManager>();
	}
};
static_assert(alignof(UWM_InputManager) == 0x000008, "Wrong alignment on UWM_InputManager");
static_assert(sizeof(UWM_InputManager) == 0x000748, "Wrong size on UWM_InputManager");
static_assert(offsetof(UWM_InputManager, HIDJoystick_KeysByType) == 0x000528, "Member 'UWM_InputManager::HIDJoystick_KeysByType' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_Axes) == 0x000578, "Member 'UWM_InputManager::HIDJoystick_Axes' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_Buttons) == 0x0005C8, "Member 'UWM_InputManager::HIDJoystick_Buttons' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, HIDJoystick_DPADs) == 0x000618, "Member 'UWM_InputManager::HIDJoystick_DPADs' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, EnableHIDInternalButtonEvents) == 0x000708, "Member 'UWM_InputManager::EnableHIDInternalButtonEvents' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, Status) == 0x000709, "Member 'UWM_InputManager::Status' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, NumGamepads) == 0x00070C, "Member 'UWM_InputManager::NumGamepads' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, NumKeyboards) == 0x000710, "Member 'UWM_InputManager::NumKeyboards' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, NumMouses) == 0x000714, "Member 'UWM_InputManager::NumMouses' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, AutoAssignDevicesByDeviceSlot) == 0x000718, "Member 'UWM_InputManager::AutoAssignDevicesByDeviceSlot' has a wrong offset!");
static_assert(offsetof(UWM_InputManager, ShowOnlyUsedInputs) == 0x000730, "Member 'UWM_InputManager::ShowOnlyUsedInputs' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_Settings
// 0x0080 (0x00B8 - 0x0038)
class UWM_Settings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_1CA2[0x20];                                    // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultPlayerIndex_DeviceAssigment;                // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSensitivity;                                // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDeadzone;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bENABLE_AUTO_BUTTON_RELEASE;                       // 0x0064(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LogConnectDisconnect;                              // 0x0065(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InitAPI_Manually;                                  // 0x0066(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenSupportWebsite;                                // 0x0067(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA3[0x50];                                    // 0x0068(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_Settings">();
	}
	static class UWM_Settings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_Settings>();
	}
};
static_assert(alignof(UWM_Settings) == 0x000008, "Wrong alignment on UWM_Settings");
static_assert(sizeof(UWM_Settings) == 0x0000B8, "Wrong size on UWM_Settings");
static_assert(offsetof(UWM_Settings, DefaultPlayerIndex_DeviceAssigment) == 0x000058, "Member 'UWM_Settings::DefaultPlayerIndex_DeviceAssigment' has a wrong offset!");
static_assert(offsetof(UWM_Settings, DefaultSensitivity) == 0x00005C, "Member 'UWM_Settings::DefaultSensitivity' has a wrong offset!");
static_assert(offsetof(UWM_Settings, DefaultDeadzone) == 0x000060, "Member 'UWM_Settings::DefaultDeadzone' has a wrong offset!");
static_assert(offsetof(UWM_Settings, bENABLE_AUTO_BUTTON_RELEASE) == 0x000064, "Member 'UWM_Settings::bENABLE_AUTO_BUTTON_RELEASE' has a wrong offset!");
static_assert(offsetof(UWM_Settings, LogConnectDisconnect) == 0x000065, "Member 'UWM_Settings::LogConnectDisconnect' has a wrong offset!");
static_assert(offsetof(UWM_Settings, InitAPI_Manually) == 0x000066, "Member 'UWM_Settings::InitAPI_Manually' has a wrong offset!");
static_assert(offsetof(UWM_Settings, OpenSupportWebsite) == 0x000067, "Member 'UWM_Settings::OpenSupportWebsite' has a wrong offset!");

// Class WM_InputManager_Plugin.WM_UmgBase
// 0x0000 (0x02C0 - 0x02C0)
class UWM_UmgBase final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WM_UmgBase">();
	}
	static class UWM_UmgBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWM_UmgBase>();
	}
};
static_assert(alignof(UWM_UmgBase) == 0x000008, "Wrong alignment on UWM_UmgBase");
static_assert(sizeof(UWM_UmgBase) == 0x0002C0, "Wrong size on UWM_UmgBase");

}

