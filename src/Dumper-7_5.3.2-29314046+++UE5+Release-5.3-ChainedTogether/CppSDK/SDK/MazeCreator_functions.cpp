#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MazeCreator

#include "Basic.hpp"

#include "MazeCreator_classes.hpp"
#include "MazeCreator_parameters.hpp"


namespace SDK
{

// Function MazeCreator.MazeCreator_C.Add Floor
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMazeCreator_C::Add_Floor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Add Floor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MazeCreator.MazeCreator_C.Corner is Inside Maze?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        Corner_Location                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return_Value                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Corner_is_Inside_Maze_(const struct FVector2D& Corner_Location, bool* Return_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Corner is Inside Maze?");

	Params::MazeCreator_C_Corner_is_Inside_Maze_ Parms{};

	Parms.Corner_Location = std::move(Corner_Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Return_Value != nullptr)
		*Return_Value = Parms.Return_Value;
}


// Function MazeCreator.MazeCreator_C.ExecuteUbergraph_MazeCreator
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::ExecuteUbergraph_MazeCreator(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "ExecuteUbergraph_MazeCreator");

	Params::MazeCreator_C_ExecuteUbergraph_MazeCreator Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.Generate Maze
// (BlueprintCallable, BlueprintEvent)

void AMazeCreator_C::Generate_Maze()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Generate Maze");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MazeCreator.MazeCreator_C.Get Adjacent Unvisited Cells
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Cell_Index                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           Adjacent_Cell_Indices                                  (Parm, OutParm)
// bool                                    Return_Value                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Get_Adjacent_Unvisited_Cells(int32 Cell_Index, TArray<int32>* Adjacent_Cell_Indices, bool* Return_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Get Adjacent Unvisited Cells");

	Params::MazeCreator_C_Get_Adjacent_Unvisited_Cells Parms{};

	Parms.Cell_Index = Cell_Index;

	UObject::ProcessEvent(Func, &Parms);

	if (Adjacent_Cell_Indices != nullptr)
		*Adjacent_Cell_Indices = std::move(Parms.Adjacent_Cell_Indices);

	if (Return_Value != nullptr)
		*Return_Value = Parms.Return_Value;
}


// Function MazeCreator.MazeCreator_C.Get Adjacent Visited Cells
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Cell_Index                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           Adjacent_Cell_Indices                                  (Parm, OutParm)
// bool                                    Return_Value                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Get_Adjacent_Visited_Cells(int32 Cell_Index, TArray<int32>* Adjacent_Cell_Indices, bool* Return_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Get Adjacent Visited Cells");

	Params::MazeCreator_C_Get_Adjacent_Visited_Cells Parms{};

	Parms.Cell_Index = Cell_Index;

	UObject::ProcessEvent(Func, &Parms);

	if (Adjacent_Cell_Indices != nullptr)
		*Adjacent_Cell_Indices = std::move(Parms.Adjacent_Cell_Indices);

	if (Return_Value != nullptr)
		*Return_Value = Parms.Return_Value;
}


// Function MazeCreator.MazeCreator_C.Get Cell Index
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   X                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Y                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Get_Cell_Index(int32 X, int32 Y, int32* Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Get Cell Index");

	Params::MazeCreator_C_Get_Cell_Index Parms{};

	Parms.X = X;
	Parms.Y = Y;

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;
}


// Function MazeCreator.MazeCreator_C.Get Cell Location
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Cell                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Get_Cell_Location(int32 Cell, struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Get Cell Location");

	Params::MazeCreator_C_Get_Cell_Location Parms{};

	Parms.Cell = Cell;

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function MazeCreator.MazeCreator_C.Get Cell X & Y
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Get_Cell_X___Y(int32 Param_Index, int32* X, int32* Y)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Get Cell X & Y");

	Params::MazeCreator_C_Get_Cell_X___Y Parms{};

	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;
}


// Function MazeCreator.MazeCreator_C.Get Dist. Between Edge Indices
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   A                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   B                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Distance_Between_Indices                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Get_Dist__Between_Edge_Indices(int32 A, int32 B, int32* Distance_Between_Indices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Get Dist. Between Edge Indices");

	Params::MazeCreator_C_Get_Dist__Between_Edge_Indices Parms{};

	Parms.A = A;
	Parms.B = B;

	UObject::ProcessEvent(Func, &Parms);

	if (Distance_Between_Indices != nullptr)
		*Distance_Between_Indices = Parms.Distance_Between_Indices;
}


// Function MazeCreator.MazeCreator_C.Get Indices to Create Room
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Room_Bottom_Corner                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Room_Width                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Room_Height                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           Cell_Indices                                           (Parm, OutParm)
// int32                                   Old_Cell                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Old_Width                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Old_Height                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Get_Indices_to_Create_Room(int32 Room_Bottom_Corner, int32 Room_Width, int32 Room_Height, TArray<int32>* Cell_Indices, int32* Old_Cell, int32* Old_Width, int32* Old_Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Get Indices to Create Room");

	Params::MazeCreator_C_Get_Indices_to_Create_Room Parms{};

	Parms.Room_Bottom_Corner = Room_Bottom_Corner;
	Parms.Room_Width = Room_Width;
	Parms.Room_Height = Room_Height;

	UObject::ProcessEvent(Func, &Parms);

	if (Cell_Indices != nullptr)
		*Cell_Indices = std::move(Parms.Cell_Indices);

	if (Old_Cell != nullptr)
		*Old_Cell = Parms.Old_Cell;

	if (Old_Width != nullptr)
		*Old_Width = Parms.Old_Width;

	if (Old_Height != nullptr)
		*Old_Height = Parms.Old_Height;
}


// Function MazeCreator.MazeCreator_C.End Locations
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Start_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   End_Index                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::End_Locations(int32* Start_Index, int32* End_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "End Locations");

	Params::MazeCreator_C_End_Locations Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Start_Index != nullptr)
		*Start_Index = Parms.Start_Index;

	if (End_Index != nullptr)
		*End_Index = Parms.End_Index;
}


// Function MazeCreator.MazeCreator_C.Get Total Outer Edges
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Return_Value                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Get_Total_Outer_Edges(int32* Return_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Get Total Outer Edges");

	Params::MazeCreator_C_Get_Total_Outer_Edges Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return_Value != nullptr)
		*Return_Value = Parms.Return_Value;
}


// Function MazeCreator.MazeCreator_C.Initialize Variables
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMazeCreator_C::Initialize_Variables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Initialize Variables");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MazeCreator.MazeCreator_C.Maze End_Begin Overlap__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       SweepResult                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AMazeCreator_C::Maze_End_Begin_Overlap__DelegateSignature(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Maze End_Begin Overlap__DelegateSignature");

	Params::MazeCreator_C_Maze_End_Begin_Overlap__DelegateSignature Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.Maze End_End Overlap__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Maze_End_End_Overlap__DelegateSignature(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Maze End_End Overlap__DelegateSignature");

	Params::MazeCreator_C_Maze_End_End_Overlap__DelegateSignature Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.Maze Start_Begin Overlap__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       SweepResult                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AMazeCreator_C::Maze_Start_Begin_Overlap__DelegateSignature(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Maze Start_Begin Overlap__DelegateSignature");

	Params::MazeCreator_C_Maze_Start_Begin_Overlap__DelegateSignature Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.Maze Start_End Overlap__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Maze_Start_End_Overlap__DelegateSignature(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Maze Start_End Overlap__DelegateSignature");

	Params::MazeCreator_C_Maze_Start_End_Overlap__DelegateSignature Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.OnMazeEndBeginOverlap
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AMazeCreator_C::OnMazeEndBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "OnMazeEndBeginOverlap");

	Params::MazeCreator_C_OnMazeEndBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.OnMazeEndEndOverlap
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::OnMazeEndEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "OnMazeEndEndOverlap");

	Params::MazeCreator_C_OnMazeEndEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.OnMazeStartBeginOverlap
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AMazeCreator_C::OnMazeStartBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "OnMazeStartBeginOverlap");

	Params::MazeCreator_C_OnMazeStartBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.OnMazeStartEndOverlap
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::OnMazeStartEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "OnMazeStartEndOverlap");

	Params::MazeCreator_C_OnMazeStartEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AMazeCreator_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MazeCreator.MazeCreator_C.Rectangle Edge is Vertical?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Param_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Width                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Height                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Is_Vertical_                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_Relative_To_Side                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Rectangle_Edge_is_Vertical_(int32 Param_Index, int32 Width, int32 Height, bool* Is_Vertical_, int32* Index_Relative_To_Side)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Rectangle Edge is Vertical?");

	Params::MazeCreator_C_Rectangle_Edge_is_Vertical_ Parms{};

	Parms.Param_Index = Param_Index;
	Parms.Width = Width;
	Parms.Height = Height;

	UObject::ProcessEvent(Func, &Parms);

	if (Is_Vertical_ != nullptr)
		*Is_Vertical_ = Parms.Is_Vertical_;

	if (Index_Relative_To_Side != nullptr)
		*Index_Relative_To_Side = Parms.Index_Relative_To_Side;
}


// Function MazeCreator.MazeCreator_C.Remove Adjacent Orphaned Corners
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Remove_Adjacent_Orphaned_Corners(const struct FVector2D& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Remove Adjacent Orphaned Corners");

	Params::MazeCreator_C_Remove_Adjacent_Orphaned_Corners Parms{};

	Parms.Origin = std::move(Origin);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.Remove Corner Pieces in Range
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Lower_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Range_Width                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Range_Height                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector2D>                Removed_Corners                                        (Parm, OutParm)

void AMazeCreator_C::Remove_Corner_Pieces_in_Range(int32 Lower_Index, int32 Range_Width, int32 Range_Height, TArray<struct FVector2D>* Removed_Corners)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Remove Corner Pieces in Range");

	Params::MazeCreator_C_Remove_Corner_Pieces_in_Range Parms{};

	Parms.Lower_Index = Lower_Index;
	Parms.Range_Width = Range_Width;
	Parms.Range_Height = Range_Height;

	UObject::ProcessEvent(Func, &Parms);

	if (Removed_Corners != nullptr)
		*Removed_Corners = std::move(Parms.Removed_Corners);
}


// Function MazeCreator.MazeCreator_C.Remove Old Maze
// (Public, BlueprintCallable, BlueprintEvent)

void AMazeCreator_C::Remove_Old_Maze()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Remove Old Maze");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MazeCreator.MazeCreator_C.Set Current Cell
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMazeCreator_C::Set_Current_Cell(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "Set Current Cell");

	Params::MazeCreator_C_Set_Current_Cell Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MazeCreator.MazeCreator_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AMazeCreator_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MazeCreator_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}

}

